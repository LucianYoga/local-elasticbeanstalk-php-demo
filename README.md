# Local Elastic Beanstalk PHP Demo

This is a demonstration of running multiple containers locally using Amazon's Elastic Beanstalk.

In truth, all Elastic Beanstalk will be doing for us here will be generating a `docker-compose.yml`
file (in `.elasticbeanstalk`), but once we're happy with the results, we can easily use the same
configuration to run our containers on AWS usng Elastic Beanstalk.

We want to be able to:

* Install and use Docker on Mac OSX
* Build a custom apache-php5 Docker image using a `Dockerfile`, fully provisioned and ready for our app
* Build a Docker image containing our app on top of this apache-php5 Docker image
* Run up containers locally from the Docker image using Elastic Beanstalk's `eb local run`

Our app will do nothing more arduous than displaying the information generated by `phpinfo()`
and show that it can connect to a MySQL database.

Note that we build a apache-php5 Docker image first, and then another image containing our app
on top of this image. This allows us to re-use the existing apache-php5 Docker image
whenever our app changes, and thus speeds up our builds.


## Installation

We use `docker-machine` on OSX via the [Docker ToolBox](https://www.docker.com/products/docker-toolbox).
As we're using Max OSX, this means that we'll end up with a Virtualbox Linux VM that will be used to run Docker.

Start our `docker-machine`:

    docker-machine start default

Add our environment variables to `.env_local`:

    #!/bin/bash
    export DOCKER_MACHINE=default
    export DOCKER_USER=mebooks
    export DOCKER_EMAIL=jcdarwin@gmail.com
    export DOCKER_PASSWORD=WHATEVER

    eval "$(docker-machine env $DOCKER_MACHINE)"

Set permissions:

    chmod a+g .env_local

Apply our environment variables:

    . ./.env_local

We should then see our environment values based on `docker-machine config default`

    env | grep DOCKER

        DOCKER_PASSWORD=WHATEVER
        DOCKER_HOST=tcp://192.168.99.101:2376
        DOCKER_MACHINE_NAME=default
        DOCKER_TLS_VERIFY=1
        DOCKER_MACHINE=default
        DOCKER_USER=mebooks
        DOCKER_CERT_PATH=/Users/jasondarwin/.docker/machine/machines/default
        DOCKER_EMAIL=jcdarwin@gmail.com

Note that running the `.env_local` loads the environment so we can use docker
from the local shell, and does the same as:

    eval "$(docker-machine env default)"


## Setup docker so we can use it from our current shell

Port-forward in `VirtualBox`, so we can access port 80 transparently:

    VBoxManage list vms
    VBoxManage modifyvm "defaut" --natpf1 "guestnginx,tcp,,80,,80"

Once installed, we can see that `docker` is at version 10.1:

    docker -v
    $ Docker version 1.10.2, build c3959b1


## Install `awsebcli`

We install the `awsebcli` using homebrew:

    brew install awsebcli

However, [there's a problem with the version compatibility check](https://forums.aws.amazon.com/thread.jspa?threadID=225425), meaning that awsebcli thinks that docker 1.10.2 is < docker 1.6, and we receive the following message:

    "You must install Docker version 1.6.0 to continue. If you are using Mac OS X, ensure you have boot2docker version 1.6.0. Currently, "eb local" does not support Windows."

To rectify this, currently we must edit `/usr/local/Cellar/aws-elasticbeanstalk/3.7.3/libexec/lib/python2.7/site-packages/ebcli/containers/compat.py` as follows, by changing:

    def supported_docker_installed():
        """
        Return whether proper Docker version is installed.
        :return: bool
        """

        try:
            return commands.version() >= SUPPORTED_DOCKER_V
        # OSError = Not installed
        # CommandError = docker versions less than 1.5 give exit code 1
        # with 'docker --version'.
        except (OSError, CommandError):
            return False

to

    def supported_docker_installed():
        """
        Return whether proper Docker version is installed.
        :return: bool
        """

        try:
            #return commands.version() >= SUPPORTED_DOCKER_V
            return True
        # OSError = Not installed
        # CommandError = docker versions less than 1.5 give exit code 1
        # with 'docker --version'.
        except (OSError, CommandError):
            return False


## Installing Composer

    curl -sS https://getcomposer.org/installer | sudo php -- --install-dir=/usr/local/bin --filename=composer

Use composer to install our dependencies

    cd php-app
    composer install


## App environment variables

We need to make certain environment variables available to our PHP scripts, particularly
those to do with connecting to our MySQL container.

To do this, we create a `php-app/.env` file, with placeholders for the expected
environment variables:

    # php-app/.env
    # The variables below are replaced during container startup by init.sh
    DB_HOST="${MYSQL_PORT_3306_TCP_ADDR}"
    DB_DATABASE="${MYSQL_ENV_MYSQL_DATABASE}"
    DB_USERNAME=root
    DB_PASSWORD="${MYSQL_ENV_MYSQL_ROOT_PASSWORD}"

We then use our `init.sh` script to read the environment variables during the
initialisation of our PHP container, and replace the placeholders in `.env` with
the values:

    # Make a copy of our .env file, as we don't want to pollute the original
    cp /var/www/html/.env /tmp/

    # Update the app configuration to make the service environment
    # variables available.
    function setEnvironmentVariable() {
        if [ -z "$2" ]; then
            echo "Environment variable '$1' not set."
            return
        fi

        # Check whether variable already exists
        if grep -q "\${$1}" /tmp/.env; then
            # Reset variable
            sed -i "s/\${$1}/$2/g" /tmp/.env
        fi
    }

    # Grep for variables that look like MySQL (MYSQL)
    for _curVar in `env | grep MYSQL | awk -F = '{print $1}'`;do
        # awk has split them by the equals sign
        # Pass the name and value to our function
        setEnvironmentVariable ${_curVar} ${!_curVar}
    done

    # Now that /tmp/.env is populated, we can start/restart apache
    # and let our PHP scripts access them.
    service apache2 restart


## Create our Makefile

We use a Makefile to make our builds slightly easier:

    BASE_IMAGE=mebooks/apache-php5
    APP_IMAGE=mebooks/php-app
    APP=php-app
    VERSION=`git describe --tags`
    CORE_VERSION=HEAD

    all: build-base prepare

    base: build-base push-base

    app: prepare-app build-app push-app

    build-base:
        docker build -t $(BASE_IMAGE):$(VERSION) docker/base

    push-base:
        . ./.env_local
        docker login --username=$(DOCKER_USER) --email=$(DOCKER_EMAIL) --password=$(DOCKER_PASSWORD)
        docker push $(BASE_IMAGE)

    prepare-app:
        # Update Dockerrun.aws.json with the current image version
        sed -i '' "s~${APP_IMAGE}\:[^\"]*~${APP_IMAGE}\:$(VERSION)~g" Dockerrun.aws.json
        git archive --format tgz HEAD $(APP) > docker/app/$(APP).tgz

    build-app:
        docker build -t $(APP_IMAGE):$(VERSION) docker/app

    push-app:
        . ./.env_local
        docker login --username=$(DOCKER_USER) --email=$(DOCKER_EMAIL) --password=$(DOCKER_PASSWORD)
        docker push mebooks/php-app


## Build the docker images

Commit and tag our changes

    git tag 2.3.0

Build our apache-php base docker image:

    make base
    docker images

Edit `docker/app/Dockerfile` and ensure that we refering to the same version
as that that we just built:

    FROM mebooks/apache-php5:2.3.0

Build our app docker image.
Note that our app docker image wil be tagged with the current version of the repo
and our `Dockerrun.aws.json` file updated accordingly.

    make app

As we've tagged our `Dockerrun.aws.json` file with the current version of the repo,
we need to commit changes, otherwise the `eb create` / `eb deploy`
(which uses `git archive`) will use the previous version of the `Dockerrun.aws.json` file.

## Check that our containers function as expected

    # Set our environment variable
    VERSION=`git describe --tags` && echo $VERSION

    # Start just the PHP container
    docker run -tid -p 80:80 \
        --name=php-app \
        mebooks/php-app:${VERSION}

    # Start both containers linked
    docker run -p 3306:3306 \
        -e MYSQL_USERNAME=root \
        -e MYSQL_ROOT_PASSWORD=password \
        -e MYSQL_DATABASE=my_db \
        -d \
        --name mysqlserver \
        mysql

    docker run -tid -p 80:80 \
        --name=php-app \
        --link mysqlserver:mysqldb \
        mebooks/php-app:${VERSION}

We should now be able to see the PHP Info details at the address reported by `docker-machine ip`, e.g.:

    docker-machine ip
    $ http://192.168.99.101/

We should also be able to see a simple example of connecting to our MySQL database at http://192.168.99.101/mysql.php


## Push our images to docker.io

Login to our docker account:

    # Enter the username, password and email when prompted
    docker login

    # Alternatively, specify username and email, and enter password when prompted
    docker login --username=mebooks --email=jcdarwin@gmail.com --password=WHATEVER

The login will create a config file at `~/.docker/config.json` if it doesn't already exist

AWS currently uses an older format of the docker config, so we need to change our current
`~/.docker/config.json` to the required format by removing the `auths` wrapper:

    # ~/.docker/config.json
    {
        "auths": {
            "https://index.docker.io/v1/": {
                "auth": "WHATEVER",
                "email": "jcdarwin@gmail.com"
            }
        }
    }

becomes

    # ~/.docker/.dockercfg.json
    {
            "https://index.docker.io/v1/": {
                "auth": "WHATEVER",
                "email": "jcdarwin@gmail.com"
            }
    }

We now need to push this to a suitable s3 bucket so Elastic Beanstalk can use it to download
our images from our private repository.

    s3cmd put ~/.docker/.dockercfg.json s3://elasticbeanstalk-ap-southeast-2-342732433199

Push our images to docker:

    docker push mebooks/apache-php5
    docker push mebooks/php-app

Note that the `make app` task automatically does the `docker push mebooks/php-app`


## Create our `Dockerrun.aws.json` (multi-container version)

We can use a multi-container `Dockerrun.aws.json` if we want to use `eb local run`
to spin up both our `php-app` container and an associated `mysql` container.

    {
        "AWSEBDockerrunVersion": 2,
        "containerDefinitions": [
            {
                "name": "mysql",
                "image": "mysql:5.6",
                "essential": true,
                "portMappings": [
                    {
                        "hostPort": 3306,
                        "containerPort": 3306
                    }
                ],
                "environment": [
                    {
                        "name": "MYSQL_USERNAME",
                        "value": "root"
                    },
                    {
                        "name": "MYSQL_PASSWORD",
                        "value": "password"
                    },
                    {
                        "name": "MYSQL_DB_NAME",
                        "value": "my_db"
                    }
                ]
            },
            {
                "name": "php-app",
                "image": "mebooks/php-app",
                "essential": true,
                "memory": 128,
                "portMappings": [
                    {
                        "hostPort": 80,
                        "containerPort": 80
                    }
                ],
                "links": [
                    "mysql"
                ]
            }
        ]
    }


Note that we specify a (very) weak `MYSQL_ROOT_PASSWORD` in our `Dockerrun.aws.json`
-- you'll want to change this and not have it under version control.


## Run our containers locally

Finally, use `eb local` to create our docker containers locally:

    eb local run

In a second terminal

    eb local status
    docker ps


## Accessing the containers

Find the appropriate container id, and start a bash shell on it:

    docker ps

    $ CONTAINER ID        IMAGE
    $ 832af3ff45d8        mebooks/apache-php5:latest
    $ fc6a9553583f        mysql:5.6

    # Access our PHP container
    docker exec -it 832af3ff45d8 bash

Alternatively, we can use `eb` to find the details, include human-readable container names

    eb local status

    $ Platform: 64bit Amazon Linux 2015.09 v2.0.8 running Multi-container Docker 1.9.1 (Generic)
    $ Container name: elasticbeanstalk_mysql_1
    $ Container ip: 127.0.0.1
    $ Container running: True
    $ Exposed host port(s): 3306
    $ Full local URL(s): 127.0.0.1:3306

    $ Container name: elasticbeanstalk_phpapache_1
    $ Container ip: 127.0.0.1
    $ Container running: True
    $ Exposed host port(s): 80
    $ Full local URL(s): 127.0.0.1:80

Access our PHP container

    docker exec -it elasticbeanstalk_phpapache_1 bash

    # check our apache config
    apachectl configtest

    # view our apache config
    cat /etc/apache2/sites-enabled/vhost.conf

    # Find the ip of our MySQL container
    env | grep MYSQL_1_PORT_3306_TCP_ADDR

    $ ELASTICBEANSTALK_MYSQL_1_PORT_3306_TCP_ADDR=172.17.0.2
    $ MYSQL_1_PORT_3306_TCP_ADDR=172.17.0.2

    # Login to mysql
    mysql -u root -h 172.17.0.2  -p

Access our MySQL container

    docker exec -it elasticbeanstalk_mysql_1 bash

    # Display our databases -- we should see my_db
    mysql -u root -p -e "show databases;"


## Create our `Dockerrun.aws.json` (single container version)

Although the multi-container version above is useful for testing locally,
in production we'll be using RDS to host MySQL, so we'll use a single container
`Dockerrun.aws.json`


## Initialise our Elastic Beanstalk app

Now, we need to initialise our `.elasticbeanstalk/config.yml`:

    eb init

More info about the `eb cli` tool is to be found on the [Amazon site](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3-getting-started.html)

## Create our Elastic Beanstalk application environment

Refer https://github.com/hopsoft/relay/wiki/How-to-Deploy-Docker-apps-to-Elastic-Beanstalk

    # Create our environment, answering the prompts accordingly
    eb create -v \
        --scale 2
        --cname local-elasticbeanstalk \
        local-elasticbeanstalk

        INFO: Creating new application version using project code
        WARNING: You have uncommitted changes.
        INFO: Getting version label from git with git-describe
        Creating application version archive "app-4bbe-160402_140739".
        INFO: creating zip using git archive HEAD
        INFO: git archive output: Dockerrun.aws.json
        php-app/
        php-app/.env
        php-app/composer.json
        php-app/composer.lock
        php-app/public/
        php-app/public/index.php
        php-app/public/mysql.php
        INFO: Uploading archive to s3 location: local-elasticbeanstalk-php-demo/app-4bbe-160402_140739.zip
        Uploading local-elasticbeanstalk-php-demo/app-4bbe-160402_140739.zip to S3. This may take a while.
        Upload Complete.
        INFO: Creating AppVersion app-4bbe-160402_140739
        INFO: Creating new environment
        Environment details for: local-elasticbeanstalk
          Application name: local-elasticbeanstalk-php-demo
          Region: ap-southeast-2
          Deployed Version: app-4bbe-160402_140739
          Environment ID: e-tcwnqqmzep
          Platform: 64bit Amazon Linux 2015.09 v2.0.8 running Docker 1.9.1
          Tier: WebServer-Standard
          CNAME: local-elasticbeanstalk.ap-southeast-2.elasticbeanstalk.com
          Updated: 2016-04-02 01:07:45.314000+00:00
        Printing Status:
        INFO: createEnvironment is starting.
        INFO: Using elasticbeanstalk-ap-southeast-2-342732433199 as Amazon S3 storage bucket for environment data.
         -- Events -- (safe to Ctrl+C)

    # CTRL-C when prompted, and follow progress:
    eb status

If we want to reference and existing config, we can do tis dring creation:

    eb create -v --cfg local-elasticbeanstalk

Note that `eb create` will use the settings from `.gitattributes` to `export-ignore` files in the zip
file that it creates and uploads to s3.
As such, we have to be careful that the `Dockerrun.aws.json` file is included in the root level of our zip file.

    Creating application version archive "app-4bbe-160402_140739".
    Uploading local-elasticbeanstalk-php-demo/app-4bbe-160402_140739.zip to S3. This may take a while.

We can easily download this zip file and inspect the contents:

    s3cmd get s3://elasticbeanstalk-ap-southeast-2-342732433199/local-elasticbeanstalk-php-demo/app-4bbe-160402_140739.zip

We need to massage our configuration, so create a standard config:

    # This creates `.elasticbeanstalk/local-elasticbeanstalk.env.yml`
    eb config

Ensure we have settings as we want, e.g. the `MinSize` for autoscaling:

      aws:autoscaling:asg:
        Availability Zones: Any
        Cooldown: '360'
        Custom Availability Zones: 'ap-southeast-2'
        MaxSize: '4'
        MinSize: '2'

As per [this answer](http://serverfault.com/a/540916), there's currently no easy way to automate the attachment of an RDS database existing outside of an Elastic Beanstalk environment to the environment during creation.

Instead, ff you want the RDS instance to exist outside of the environment you can simply provide the connection parameters as environment variables via the EB Console: Configuration -> Web Layer -> Software Configuration:

    RDS_HOSTNAME: mebooks-mysql-dbinstance.criieggarwwz.ap-southeast-2.rds.amazonaws.com
    RDS_DB_NAME : my_db
    RDS_USERNAME: root
    RDS_PASSWORD: WHATEVER

These environment variables can then be [accessed from inside your PHP app](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_PHP.rds.html#create_deploy_PHP.rds.newDB).

We can ssh into our load balancer, and then telnet to our instances:

    eb ssh
    sudo -s
    yum install telnet
    telnet mebooks-mysql-dbinstance.criieggarwwz.ap-southeast-2.rds.amazonaws.com

Once we know the public DNS of our ec2 instance, we can directly ssh in as `ec2-user`.

    ssh -i ~/.ssh/aws-eb  ec2-user@ec2-52-62-4-141.ap-southeast-2.compute.amazonaws.com

    # Once logged in, elevate to root to be able to acces docker:
    sudo -s


## Redeploying

Successive deployments should be a matter of:

    make app

As we've tagged our `Dockerrun.aws.json` file with the current version of the repo,
we need to commit changes, otherwise the `eb create` / `eb deploy`
(which uses `git archive`) will use the previous version of the `Dockerrun.aws.json` file.
    git commit -m "Whatever"

    eb deploy -v local-elasticbeanstalk


## Terminating

Once we've finished with a particular environment, we can terminate it:

    eb terminate local-elasticbeanstalk

## Cleaning up

Once we're finished, remove our containers, either by id or by name

    docker rm 832af3ff45d8 fc6a9553583f

If we're finished with our image, we can delete it:

    docker rmi mebooks/apache-php5


## RDS

Create our RDS instance.
We'll use:

* RDS MySQL
* T2 Small
* Multi-AZ
* Allocated storage: 5GB
* DB Instance Identifier: mebooks-mysql-dbinstance
* Master Username: root

Ensure that the security group allows connections to and from port 3306, and that the EC2 instances
will be also using this security group.

Once setup, we should be able to connect from an EC2 instance in the same group as follows:

    mysql -h mebooks-mysql-dbinstance.criieggarwwz.ap-southeast-2.rds.amazonaws.com -u root -p


## Further

* http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker-eblocal.html
* http://victorlin.me/posts/2014/11/26/running-docker-with-aws-elastic-beanstalk
* https://github.com/hopsoft/relay/wiki/How-to-Deploy-Docker-apps-to-Elastic-Beanstalk
* http://www.sitepoint.com/docker-and-dockerfiles-made-easy/
* http://www.michaelgallego.fr/blog/2015/07/18/using-elastic-beanstalk-multi-container-with-php/
